"""
Main pipeline script for Pan-Cancer Mutational Signature Analysis.

Orchestrates the execution of various analysis stages including data download (placeholder),
preprocessing (placeholder), signature discovery (placeholder), TMB calculation,
GSEA ranked list generation, GSEA analysis, GSEA summary plotting, and final PDF report generation.
"""
import argparse
import os
import sys
import subprocess 
import shutil 

# Define all possible stages of the pipeline
ALL_STAGES = [
    "download_data",                      # Placeholder (scripts/download_tcga_mafs.py)
    "preprocess_data",                    # Placeholder (scripts/preprocess_mafs.py)
    "train_lda_model",                    # Placeholder (scripts/train_lda_model.py)
    "visualize_signatures",               # Placeholder (scripts/visualize_signatures.py)
    "compare_to_cosmic",                  # Placeholder (scripts/compare_to_cosmic.py)
    "generate_sample_map",                # Placeholder (scripts/generate_sample_cohort_map.py)
    "analyze_exposures",                  # Placeholder (scripts/analyze_patient_exposures.py)
    "calculate_tmb",                      # scripts/calculate_tmb.py
    "generate_gsea_ranked_list_diffmut",  # scripts/generate_gsea_ranked_list.py (for each GSEA pair)
    "generate_gsea_ranked_list_regression",# scripts/generate_regression_ranked_list.py (for each GSEA pair)
    "run_gsea",                           # scripts/run_gsea_analysis.py (for each GSEA pair, for each ranked list type)
    "plot_gsea_summary",                  # scripts/plot_gsea_summary.py (for each GSEA pair, for each ranked list type)
    "generate_report"                     # scripts/generate_report.py
]

# Helper function to get script path
def get_script_path(script_name):
    """Constructs the full path to a script in the 'scripts' directory."""
    script_path = os.path.join("scripts", script_name)
    return script_path

class PipelinePaths:
    """
    Defines and stores paths for the pipeline based on input arguments.
    """
    def __init__(self, args, processed_cohort_ids, gsea_signature_cohort_pairs):
        self.args = args
        self.processed_cohort_ids_list = sorted(processed_cohort_ids)
        self.processed_cohort_ids_str = "_".join(self.processed_cohort_ids_list)

        # --- Base Directories ---
        self.base_data_dir = args.base_data_dir
        self.base_results_dir = args.base_results_dir
        
        # --- Processed Data Directory (New) ---
        self.processed_data_dir = os.path.join(self.base_data_dir, "processed")

        # --- Data Directories (Inputs to the pipeline scripts) ---
        self.maf_download_dir = os.path.join(self.base_data_dir, "raw_mafs") # Changed from "mafs"
        self.metadata_dir = os.path.join(self.base_data_dir, "metadata") 
        self.gene_sets_dir = os.path.join(self.base_data_dir, "gene_sets")

        # --- File Paths (Outputs from some stages, inputs to others) ---
        self.mutation_catalog_file = os.path.join(self.base_results_dir, "tables", "mutation_catalog.csv") # Changed to .csv

        # LDA & Signature Analysis Results
        self.lda_model_dir = os.path.join(self.base_results_dir, "lda_models")
        self.lda_model_file = os.path.join(self.lda_model_dir, f"lda_model_k{args.k_lda}_seed{args.lda_seed}.pkl")
        self.patient_exposures_file = os.path.join(self.lda_model_dir, f"patient_exposures_k{args.k_lda}_seed{args.lda_seed}.csv") # Changed to .csv
        self.signature_profiles_file = os.path.join(self.lda_model_dir, f"signature_profiles_k{args.k_lda}_seed{args.lda_seed}.csv") # Added
        self.signature_plots_dir = os.path.join(self.base_results_dir, "figures", "signatures")
        
        self.cosmic_comparison_dir = os.path.join(self.base_results_dir, "comparison") # Verified
        self.cosmic_comparison_csv_file = os.path.join(self.cosmic_comparison_dir, f"cosmic_comparison_k{args.k_lda}_s{args.lda_seed}.csv")
        self.cosmic_comparison_plot_file = os.path.join(self.cosmic_comparison_dir, f"cosmic_comparison_k{args.k_lda}_s{args.lda_seed}.png")
        
        # Sample map (generated by generate_sample_map.py)
        # self.sample_cohort_map_dir = os.path.join(self.base_results_dir, "tables") # Old location
        self.sample_cohort_map_file = os.path.join(self.processed_data_dir, "sample_cohort_map.csv") # Changed path and extension

        # Exposure Analysis Results
        self.exposure_figures_dir = os.path.join(self.base_results_dir, "figures", "exposures")

        # TMB file path
        self.tmb_output_dir = os.path.join(self.base_results_dir, "tables")
        self.tmb_file = os.path.join(self.tmb_output_dir, f"tmb_per_sample_{self.processed_cohort_ids_str}_{int(args.exome_size_mb)}Mb.tsv")
        
        self.tmb_column_for_regression = "TMB_mut_per_Mb" if args.exome_size_mb > 0 else "Total_SNVs"

        # --- GSEA Related Paths ---
        self.ranked_gene_lists_base_dir = os.path.join(self.base_results_dir, "ranked_gene_lists")
        self.gsea_analysis_base_dir = os.path.join(self.base_results_dir, "gsea_reports")
        self.gsea_summary_plots_base_dir = os.path.join(self.base_results_dir, "figures", "gsea_summary")

        self.gsea_paths_config = [] 
        for pair in gsea_signature_cohort_pairs:
            sig_cohort_label = f"{pair['cohort']}_{pair['signature']}"
            self.gsea_paths_config.append({
                "pair_label": sig_cohort_label, "signature": pair['signature'], "cohort": pair['cohort'],
                "diffmut_ranked_list_file": os.path.join(self.ranked_gene_lists_base_dir, f"{sig_cohort_label}_diffmut_ranked.rnk"),
                "diffmut_gsea_output_dir": os.path.join(self.gsea_analysis_base_dir, f"{sig_cohort_label}_diffmut"),
                "diffmut_gsea_results_csv": os.path.join(self.gsea_analysis_base_dir, f"{sig_cohort_label}_diffmut", "gseapy.prerank.gene_sets.report.csv"),
                "diffmut_gsea_summary_plot_file": os.path.join(self.gsea_summary_plots_base_dir, f"{sig_cohort_label}_diffmut_top20.png"),
                "regression_ranked_list_file": os.path.join(self.ranked_gene_lists_base_dir, f"{sig_cohort_label}_regression_ranked.rnk"),
                "regression_gsea_output_dir": os.path.join(self.gsea_analysis_base_dir, f"{sig_cohort_label}_regression"),
                "regression_gsea_results_csv": os.path.join(self.gsea_analysis_base_dir, f"{sig_cohort_label}_regression", "gseapy.prerank.gene_sets.report.csv"),
                "regression_gsea_summary_plot_file": os.path.join(self.gsea_summary_plots_base_dir, f"{sig_cohort_label}_regression_top20.png"),
            })

        self.report_output_file = args.report_output_file 

        self.dirs_to_create = list(set([
            self.base_data_dir, self.base_results_dir, self.processed_data_dir, # Added processed_data_dir
            self.maf_download_dir, self.metadata_dir, self.gene_sets_dir,
            self.tmb_output_dir, self.lda_model_dir, self.signature_plots_dir,
            self.cosmic_comparison_dir, self.exposure_figures_dir, 
            # self.sample_cohort_map_dir, # Removed as sample_cohort_map_file now uses processed_data_dir
            self.ranked_gene_lists_base_dir, self.gsea_analysis_base_dir, self.gsea_summary_plots_base_dir,
            os.path.dirname(self.report_output_file) if os.path.dirname(self.report_output_file) else None
        ]))
        for gsea_config in self.gsea_paths_config:
            self.dirs_to_create.append(gsea_config["diffmut_gsea_output_dir"])
            self.dirs_to_create.append(gsea_config["regression_gsea_output_dir"])
        self.dirs_to_create = [d for d in self.dirs_to_create if d]

def create_parser():
    parser = argparse.ArgumentParser(description="Main pipeline for Pan-Cancer Mutational Signature Analysis.")
    parser.add_argument("--cohort_list", type=str, required=True, help="Comma-separated TCGA project IDs.")
    parser.add_argument("--k_lda", type=int, default=5, help="Number of LDA signatures (default: 5).")
    parser.add_argument("--lda_seed", type=int, default=42, help="Random seed for LDA (default: 42).")
    parser.add_argument("--ref_genome_fasta", type=str, required=True, help="Path to reference genome FASTA file.") # Changed
    parser.add_argument("--cosmic_signatures_file", type=str, required=True, help="Path to COSMIC signatures reference file.") # Changed
    parser.add_argument("--gmt_file", type=str, required=True, help="Path to GMT gene set file for GSEA.")
    parser.add_argument("--exome_size_mb", type=float, default=30.0, help="Exome size for TMB norm (default: 30.0).")
    parser.add_argument("--gsea_pairs", type=str, required=True, help="Comma-separated 'SignatureName:CohortID' pairs for GSEA.")
    parser.add_argument("--base_data_dir", type=str, default="./data/", help="Base dir for raw data (default: ./data/).")
    parser.add_argument("--base_results_dir", type=str, default="./results/", help="Base dir for results (default: ./results/).")
    parser.add_argument("--report_output_file", type=str, default="./results/pdf_reports/Pipeline_Report.pdf", help="Full path for PDF report.")
    parser.add_argument("--run_stages", type=str, default="all", help=f"Stages to run. Default: 'all'. Available: {', '.join(ALL_STAGES)}")
    parser.add_argument("--gsea_min_gene_set_size", type=int, default=15, help="Min gene set size for GSEA.")
    parser.add_argument("--gsea_max_gene_set_size", type=int, default=500, help="Max gene set size for GSEA.")
    parser.add_argument("--gsea_permutation_num", type=int, default=1000, help="Num permutations for GSEA.")
    parser.add_argument("--gsea_plot_top_n", type=int, default=20, help="Top N pathways for GSEA summary plot.")
    parser.add_argument("--gsea_plot_fdr_threshold", type=float, default=0.25, help="FDR threshold for GSEA plot.")
    parser.add_argument("--regression_min_mutations", type=int, default=3, help="Min mutations for regression.")
    parser.add_argument("--diffmut_min_group_size", type=int, default=10, help="Min group size for diff. mut.")
    parser.add_argument("--diffmut_high_quantile", type=float, default=0.75, help="High quantile for diff. mut.")
    parser.add_argument("--diffmut_low_quantile", type=float, default=0.25, help="Low quantile for diff. mut.")
    return parser

def run_script(command_parts, stage_name, python_executable="python"):
    print(f"\n--- Starting Stage: {stage_name} ---")
    # Ensure all command parts are strings
    command_parts_str = [str(part) for part in command_parts]
    print(f"Executing command: {' '.join(command_parts_str)}")
    try:
        result = subprocess.run(command_parts_str, check=False, text=True, capture_output=True)
        if result.returncode == 0:
            print(f"Stage '{stage_name}' completed successfully."); print(f"  Output (first 1000 chars):\n{result.stdout.strip()[:1000]}\n...")
            return True
        else:
            print(f"Error: Stage '{stage_name}' failed. RC: {result.returncode}", file=sys.stderr)
            if result.stdout: print(f"  STDOUT:\n{result.stdout.strip()}", file=sys.stderr)
            if result.stderr: print(f"  STDERR:\n{result.stderr.strip()}", file=sys.stderr)
            return False
    except FileNotFoundError:
        print(f"Error: Command for '{stage_name}' not found: '{command_parts_str[0]}'.", file=sys.stderr); return False
    except Exception as e:
        print(f"Unexpected error running '{stage_name}': {e}", file=sys.stderr); return False

def should_run_stage(stage_name, requested_stages_set): return stage_name in requested_stages_set

def _orchestrate_pipeline(args):
    """Core orchestration logic, called by main after arg parsing."""
    python_executable = sys.executable # Use the same python interpreter
    print(f"--- Pipeline Orchestration Started ---"); print(f"  Using Python: {python_executable}")
    
    cohort_ids = [c.strip() for c in args.cohort_list.split(',') if c.strip()]
    if not cohort_ids: print("Error: Cohort list empty.", file=sys.stderr); sys.exit(1)
    print(f"  Processed Cohorts: {cohort_ids}")

    gsea_pairs = []
    raw_pairs = [p.strip() for p in args.gsea_pairs.split(',') if p.strip()]
    if not raw_pairs: print("Error: GSEA pairs empty.", file=sys.stderr); sys.exit(1)
    for p_str in raw_pairs:
        if ':' not in p_str: print(f"Error: Invalid GSEA pair: '{p_str}'.", file=sys.stderr); sys.exit(1)
        sig, coh = p_str.split(':',1)
        if not sig.strip() or not coh.strip(): print(f"Error: Invalid GSEA pair (empty part): '{p_str}'.", file=sys.stderr); sys.exit(1)
        gsea_pairs.append({'signature': sig.strip(), 'cohort': coh.strip()})
    if not gsea_pairs: print("Error: No valid GSEA pairs.", file=sys.stderr); sys.exit(1)
    print(f"  Processed GSEA Pairs: {gsea_pairs}")
    
    paths = PipelinePaths(args, cohort_ids, gsea_pairs)
    print("\nCreating directories..."); 
    for d in paths.dirs_to_create: os.makedirs(d, exist_ok=True)
    print("Directories ensured.")

    stages_to_run = set(s.strip().lower() for s in args.run_stages.split(',') if s.strip())
    if "all" in stages_to_run: stages_to_run = set(ALL_STAGES)
    else:
        valid_run_stages = stages_to_run.intersection(ALL_STAGES)
        invalid_stages = stages_to_run.difference(ALL_STAGES)
        if invalid_stages: print(f"Warning: Unknown stages ignored: {', '.join(invalid_stages)}", file=sys.stderr)
        stages_to_run = valid_run_stages
    if not stages_to_run: print("Error: No valid stages to run.", file=sys.stderr); sys.exit(1)
    print(f"  Running stages: {', '.join(sorted(list(stages_to_run)))}")

    print("\n--- Pipeline Stage Execution ---")
    pipeline_failed = False
    for stage in ALL_STAGES: 
        if not should_run_stage(stage, stages_to_run):
            print(f"\n--- Skipping Stage: {stage} ---")
            continue
        success = False
        if stage == "download_data":
            cmd = [python_executable, get_script_path("download_tcga_mafs.py"), "--project_ids", args.cohort_list, "--output_dir", paths.maf_download_dir]
            success = run_script(cmd, "Download TCGA MAFs", python_executable)
        elif stage == "preprocess_data":
            cmd = [python_executable, get_script_path("preprocess_mafs.py"), "--maf_input_dir", paths.maf_download_dir, "--ref_genome_fasta", args.ref_genome_fasta, "--output_matrix_file", paths.mutation_catalog_file]
            success = run_script(cmd, "Preprocess MAFs", python_executable)
        elif stage == "train_lda_model":
            cmd = [python_executable, get_script_path("train_lda_model.py"), "--matrix_path", paths.mutation_catalog_file, "--num_signatures", str(args.k_lda), "--random_seed", str(args.lda_seed), "--output_dir_models", paths.lda_model_dir]
            success = run_script(cmd, "Train LDA Model", python_executable) # Note: output_dir_models implies script saves multiple files
        elif stage == "visualize_signatures":
            cmd = [python_executable, get_script_path("visualize_signatures.py"), "--signature_profiles_file", paths.signature_profiles_file, "--output_dir_figures", paths.signature_plots_dir]
            success = run_script(cmd, "Visualize Signatures", python_executable)
        elif stage == "compare_to_cosmic":
            cmd = [python_executable, get_script_path("compare_to_cosmic.py"), "--discovered_profiles_file", paths.signature_profiles_file, "--cosmic_profiles_file", args.cosmic_signatures_file, "--output_dir_comparison", paths.cosmic_comparison_dir]
            success = run_script(cmd, "Compare to COSMIC", python_executable)
        elif stage == "generate_sample_map":
            cmd = [python_executable, get_script_path("generate_sample_cohort_map.py"), "--maf_input_dir", paths.maf_download_dir, "--output_map_file", paths.sample_cohort_map_file]
            success = run_script(cmd, "Generate Sample Map", python_executable)
        elif stage == "analyze_exposures":
            cmd = [python_executable, get_script_path("analyze_patient_exposures.py"), "--exposures_file", paths.patient_exposures_file, "--sample_map_file", paths.sample_cohort_map_file, "--output_dir_figures", paths.exposure_figures_dir]
            success = run_script(cmd, "Analyze Patient Exposures", python_executable)
        elif stage == "calculate_tmb":
            cmd = [python_executable, get_script_path("calculate_tmb.py"), "--maf_input_dir", paths.maf_download_dir, "--cohort_list", args.cohort_list, "--exome_size_mb", str(args.exome_size_mb), "--output_tmb_file", paths.tmb_file]
            success = run_script(cmd, "Calculate TMB", python_executable)
        elif stage == "generate_gsea_ranked_list_diffmut":
            stage_success_overall = True
            for pair_config in paths.gsea_paths_config:
                cmd = [python_executable, get_script_path("generate_gsea_ranked_list.py"),
                       "--exposures_file", paths.patient_exposures_file, "--sample_map_file", paths.sample_cohort_map_file,
                       "--maf_input_dir", paths.maf_download_dir, "--target_cohort", pair_config["cohort"],
                       "--target_signature_column", pair_config["signature"], "--high_exposure_quantile", str(args.diffmut_high_quantile),
                       "--low_exposure_quantile", str(args.diffmut_low_quantile), "--min_group_size", str(args.diffmut_min_group_size),
                       "--output_ranked_gene_file", pair_config["diffmut_ranked_list_file"]]
                if not run_script(cmd, f"Generate GSEA Ranked List (DiffMut) for {pair_config['pair_label']}", python_executable):
                    stage_success_overall = False; break 
            success = stage_success_overall
        elif stage == "generate_gsea_ranked_list_regression":
            stage_success_overall = True
            for pair_config in paths.gsea_paths_config:
                cmd = [python_executable, get_script_path("generate_regression_ranked_list.py"),
                       "--exposures_file", paths.patient_exposures_file, "--sample_map_file", paths.sample_cohort_map_file,
                       "--tmb_file", paths.tmb_file, "--maf_input_dir", paths.maf_download_dir,
                       "--target_cohort", pair_config["cohort"], "--target_signature_column", pair_config["signature"],
                       "--tmb_column_name", paths.tmb_column_for_regression, "--min_mutations_per_gene", str(args.regression_min_mutations),
                       "--output_ranked_gene_file", pair_config["regression_ranked_list_file"]]
                if not run_script(cmd, f"Generate GSEA Ranked List (Regression) for {pair_config['pair_label']}", python_executable):
                    stage_success_overall = False; break
            success = stage_success_overall
        elif stage == "run_gsea":
            stage_success_overall = True
            for pair_config in paths.gsea_paths_config:
                for rnk_type in ["diffmut", "regression"]: 
                    ranked_list_file = pair_config[f"{rnk_type}_ranked_list_file"]
                    gsea_out_dir = pair_config[f"{rnk_type}_gsea_output_dir"]
                    if not os.path.exists(ranked_list_file) and os.path.getsize(ranked_list_file) > 0 : # Check if ranked list exists AND is not empty
                        print(f"  Warning: Ranked list file {ranked_list_file} not found or empty for {pair_config['pair_label']} ({rnk_type}). Skipping GSEA run.", file=sys.stderr)
                        continue 
                    cmd = [python_executable, get_script_path("run_gsea_analysis.py"),
                           "--ranked_gene_list_file", ranked_list_file, "--gene_sets_gmt_file", args.gmt_file,
                           "--output_dir_gsea", gsea_out_dir, "--min_gene_set_size", str(args.gsea_min_gene_set_size),
                           "--max_gene_set_size", str(args.gsea_max_gene_set_size), "--permutation_num", str(args.gsea_permutation_num),
                           "--seed", str(args.lda_seed)]
                    if not run_script(cmd, f"Run GSEA ({rnk_type.capitalize()}) for {pair_config['pair_label']}", python_executable):
                        stage_success_overall = False; # Don't break, try other pairs/types, but mark stage as failed
            success = stage_success_overall
        elif stage == "plot_gsea_summary":
            stage_success_overall = True
            for pair_config in paths.gsea_paths_config:
                for rnk_type in ["diffmut", "regression"]:
                    gsea_results_csv = pair_config[f"{rnk_type}_gsea_results_csv"]
                    gsea_summary_plot = pair_config[f"{rnk_type}_gsea_summary_plot_file"]
                    if not os.path.exists(gsea_results_csv) and os.path.getsize(gsea_results_csv) > 0:
                        print(f"  Warning: GSEA results CSV {gsea_results_csv} not found or empty for {pair_config['pair_label']} ({rnk_type}). Skipping plot generation.", file=sys.stderr)
                        continue
                    cmd = [python_executable, get_script_path("plot_gsea_summary.py"),
                           "--gsea_results_file", gsea_results_csv, "--top_n_pathways", str(args.gsea_plot_top_n),
                           "--output_plot_file", gsea_summary_plot, "--fdr_threshold", str(args.gsea_plot_fdr_threshold)]
                    if not run_script(cmd, f"Plot GSEA Summary ({rnk_type.capitalize()}) for {pair_config['pair_label']}", python_executable):
                        stage_success_overall = False;
            success = stage_success_overall
        elif stage == "generate_report":
            cmd = [python_executable, get_script_path("generate_report.py"), "--output_pdf_file", paths.report_output_file]
            success = run_script(cmd, "Generate PDF Report", python_executable)
        else:
            print(f"Warning: Stage '{stage}' logic not implemented. Skipping.", file=sys.stderr)
            success = True 
        if not success:
            pipeline_failed = True; break 
            
    if pipeline_failed:
        print("\n--- Main Pipeline Halted due to error in one of the stages. ---", file=sys.stderr)
        sys.exit(1)
    else:
        print("\n--- Main Pipeline Finished Successfully ---")

def main(cmd_args_list=None):
    parser = create_parser()
    try:
        args = parser.parse_args(cmd_args_list if cmd_args_list is not None else sys.argv[1:])
    except SystemExit: 
        sys.exit(2) 
    
    _orchestrate_pipeline(args)

if __name__ == "__main__":
    main()
